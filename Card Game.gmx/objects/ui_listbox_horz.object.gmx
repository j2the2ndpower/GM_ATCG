<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_ui</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>ui_defaults</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Copyright (c) 2013 NailBuster Software Inc.  all rights reserved.
/**********************

  This source code is provided 'as-is', without any express or implied warranty. 
  In no event will NailBuster Software Inc. be held liable for any damages arising from the use of this software.

      Permission is granted to use these components for non commercial applications, and to alter it for your needs,
    subject to the following restrictions:
    
  1. The origin of this software must not be misrepresented; you must not claim that you wrote the original source code 
     or components. If you use this software in a application, an acknowledgment in the product about/documentation would be appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
     You cannot distribute your modified sources of our component suite outside of your company.
  3. You cannot use this source or components in a tool or package designed to compete with NailBuster GUI component Suite. 
     For example,  you cannot modify and/or  improve these components and release under another component suite name.
  4. You cannot redistribute these source files outside of your compiled projects. All original Sources Files/Documentation 
     must originate from NailBuster Software Inc.  You cannot host or redistribute these source files. 
  
  If your application is used for commercial purposes, and will generate revenue directly or indirectly then you are required to 
  purchase a commercial license from NailBuster Software Inc.  Please visit www.nailbuster.com for purchasing information.
  If you have any questions about the license please contact us at david@nailbuster.com

**********************/


event_inherited();

items[0]='';
itemspos[0]=0;  //array of line#s for variable height rows for selection
sprites[0]=0;   //array of sprites for drawing
itemindex=-1;

CurSurface = -1;

uiSpriteIndex=0;
uiSpriteAlign=fa_center;
uiSpriteAlignV=fa_top;
uiSpriteScale=1.0;  //auto-size

numlines = 0;      //number of lines.
mouse_move = false;
mouse_movex = false;   //weather we are moving left-right.
mouse_pressedy=0;
mouse_pressedx=0;
mouse_origx = 0;
mouse_time = 0;
mouse_click = false;
first_press = false; //for mouse first press and direction
rubbery = 30 ; //number of pixels to rubberband in y
rubberx = 30 ; //number of pixels to rubberband in x
rubberbanding = false; //if we are rubberbanding then dont process mouse.
bandstep = 0;
groupheight = 0;  //height of report in pixels.
viewheight = sprite_height;  //viewable height
topclip = 0;  //line in room that is top position;
bottom=false;  //use to determine if report is showing last item currently.
bottomline = 0 ;  //will determine the drawy bottomline;
topstart=0;
left_margin = 5;
uiItemWidth = 100;  //default item width
line_clicked = -1; //index of selected item;
drawy=0;
drawx=x;
startline=0;
flicked = 0;  //if was swiped then set flicked 
noscroll=false;
uiDrawLines=true;
uiDrawHeader=true;
uiDelayEvent=1;     //if you want to delay the press to call event (for highlighting)
uiDrawSquare=true;  //because of surfaces, be can't be rounded here...
uiComboID=noone;  //set to the instance id of combo object id. for callback.
uiMemo='';
uiDrawHilite=true;
uiCredits=false;
uiCustomDrawScript=-1;
uiSurfaceHeight=0;  //override surface height (Default is textheight * numitems)
uiScrollArrows=true;
uiScrollColor=c_dkgray;
uiMoveToTop = false;   //will reset the drawy position to top
curArrowPulse=1;
curArrowSpeed=0.05;
maxLineHeight=128;  //this is important, do not make too large or else surface will be larger!!  This is the maximum height you can make an individual line.
uiAlign=fa_center;
uiAlignV=fa_bottom;
uiAutoSelect=false;
uiSnapLeft=false;    //will snap the left item to the left of the widget (no left side clipping)....
uiLeftMargin=0;




</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (surface_exists(CurSurface)) {surface_free(CurSurface);}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//calls the eventobject on select.
//its in an alarm because we support  uiDelayEvent;  for highlight/buttons
var evNum;

evNum=uiEventNum;   
if uiEventObject != noone
 if object_exists(uiEventObject) then
   with (uiEventObject) {if evNum&gt;=0 event_user(evNum);}
          

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if uiMemo !='' then  //memo set so we break apart string to items list
   {  event_user(1); }

if uiMoveToTop    //will reset listbox to top position...useful when resetting items
   { drawy=0;
     uiMoveToTop=false; }

if flicked != 0 then //we need to flick...
 {
 if rubberbanding==false
   {
    drawy+=flicked * 0.15;
    flicked=flicked * 0.85;
   } else flicked=0;
 if abs(flicked)&lt;=2 {drawy+=flicked;flicked=0;}  
 }

 
if (mouse_move==false &amp;&amp; uiCredits)  //scroll credits;
   {
     drawy=drawy- 0.6;
     if drawy&lt;=bottomline then 
        {drawy=0;
         exit;
        }        
   } 
 
if (mouse_move==false &amp;&amp; drawy&gt;0)
    { if rubberbanding ==false {rubberbanding = true;                     
                                bandstep = ((drawy) div 6) +2 ;
                                }
      if drawy&gt;0 drawy-=bandstep;
      if drawy &lt;=0 then { drawy=0;
                          rubberbanding=false;
                          flicked=0;
                        }  
    } 
    
if (mouse_move==false &amp;&amp; drawy&lt;bottomline &amp;&amp; noscroll=false)
    {    
       if rubberbanding ==false {rubberbanding = true;                     
                                 bandstep =abs( ( (drawy-bottomline) div 6))+2;
                                }
       if drawy&lt;bottomline drawy+=bandstep;
       if drawy&gt;=bottomline then 
                       { 
                        drawy=bottomline;
                        rubberbanding=false;
                        flicked=0;
                       } 
   
    } 

if (drawy&lt; (bottomline-(sprite_width div 3)) &amp;&amp; mouse_move) event_user(0);
if (drawy&gt; (sprite_width div 3) &amp;&amp; mouse_move) event_user(0);                               
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="61">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if noscroll then exit;
if position_meeting(mouse_x,mouse_y,self)
{
drawy=drawy - (sprite_width div 10);
if drawy&lt; (bottomline-(sprite_width div 3)) event_user(0);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="60">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if noscroll then exit;
if position_meeting(mouse_x,mouse_y,self)
{
drawy=drawy + (sprite_width div 10);
if drawy&gt; (sprite_width div 3) event_user(0);  
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (uiMouseHandle==false) || (uiEnabled==false) || (uiVisible==false) exit;
if mouse_move then event_user(0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (uiMouseHandle==false) || (uiEnabled==false) || (uiVisible==false) exit;

event_user(0);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (uiMouseHandle==false) || (uiEnabled==false) || (uiVisible==false) exit;

event_inherited();


//if rubberbanding exit; 

if mouse_move exit;
   else {mouse_pressedy=mouse_y;
         mouse_pressedx=mouse_x;
         mouse_move=true;        
         first_press=true; 
         mouse_origx=mouse_x; //to determine if it is a click or move.....use x in horizontal
         mouse_click=false;
         flicked=0;
         mouse_time = get_timer();
        }
        
       
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (uiMouseHandle==false) || (uiEnabled==false) || (uiVisible==false) exit;

if (mouse_move &amp;&amp; noscroll==false)
                  { drawy= drawy + (mouse_x - mouse_pressedx);
                    mouse_pressedy = mouse_y;
                    mouse_pressedx = mouse_x;
                  }      

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///break apart memo string
var curx,curword, curline, curst,fx;

draw_set_font(uiFont);

curx = 0;
curst=uiMemo;
uiMemo='';   //resets it so that we only call this event once!
curword='';
curline='';
fx=1;
items=0;  //reset items array
drawy=0;  //reset top pos
lastchar='';
while string_length(curst)&gt;fx
 {
 linebreak=false;
 //grab a word (repeat until ' ');
 curchar=string_char_at(curst,fx);
  while 1
     { 
       if (curchar != ' ') &amp;&amp; (curchar != chr(13)) &amp;&amp; (curchar != chr(10)) &amp;&amp; (curchar != '#')
           {curword = curword + curchar;}
       fx=fx+1;
       if fx&gt;string_length(curst) break;
       lastchar=curchar;
       curchar=string_char_at(curst,fx);       
       if (curchar== chr(10)) 
                           {  linebreak=true;                                  
                              break;
                           }                                                                                                 
       if (curchar== '#') {  if (lastchar != '\') {
                                                    linebreak=true;
                                                    break;
                                                  } 
                             else curword =curword+'#';
                          }   
       if (curchar==' ') break;                              
                                                
     }
  curword=curword+' ';
     
  if (string_width(curline)+string_width(' '+curword)&lt;sprite_width -3)
    {curline=curline+curword;
     curword='';
    }  
    else {  //if line too long we append and create new string.
          items[curx]=curline;
          curx=curx+1;
          curline=curword;
         }
    
  if linebreak  //if chr(10) or '#'
    {
     items[curx]=curline;
     curx=curx+1;
     curline='';
    }
  curword='';            
 }
 
if curline !='' {items[curx]=curline;}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///mouse lifted or moved off control

var evNum,numitems,snapx;
var flicktime;

mouse_move=false;
mouse_movex=false;
first_press=false;
//if startline==0 drawy=0;
rubberbanding=false;
numitems=array_length_1d(items);

//see if it is a click
if (abs (mouse_x - mouse_origx) &lt; 15) // &amp;&amp; mouse_y &gt;= y)  //a click not a move
    {mouse_click=true;
    for (fx=0;fx&lt;numitems;fx+=1)
      if itemspos[fx]&gt;((mouse_origx-x-drawy)-uiLeftMargin) 
         { itemindex=fx;
           break;
         }  
    if itemindex&gt;numitems-1 then itemindex=numitems-1;
    if itemindex&lt;0 itemindex=0;
    //process event...
    
    alarm[0]=uiDelayEvent;
    
    if uiComboID &gt;= 0      
       if instance_exists(uiComboID) then                        //for combo drop down list...
         with (uiComboID) {if evNum&gt;=0 event_user(evNum);}

    soundindex=1; //click
    event_user(10); //process sound event;   
      
       
    }  
else //see if it was a quick swipe...flicked!                              
   { 
   if noscroll exit;  //disregard if no scrolling
   flicktime= (get_timer()-mouse_time)/1000;
   if flicktime &lt; 160 then flicked=abs( (50-flicktime) + (2 * abs(mouse_x - mouse_origx)));
   if (mouse_x - mouse_origx)&lt;0 flicked=flicked* -1;  

   if uiSnapLeft   
      {snapx = ((drawy + flicked) div (uiItemWidth)) * (uiItemWidth); 
       if abs((drawy + flicked) mod (uiItemWidth)) &gt; (uiItemWidth div 2) snapx = snapx - uiItemWidth;
       flicked=snapx-drawy;
      }  
   // if uiSnapCenter  
   //   {snapx = ((drawy + flicked) div (uiItemWidth)) * (uiItemWidth); 
   //    if abs((drawy + flicked) mod (uiItemWidth)) &gt; (uiItemWidth div 2) snapx = snapx - uiItemWidth;
   //    flicked=snapx-drawy;
   //   }  
      
      
   }  
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (surface_exists(CurSurface)) {surface_free(CurSurface);}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Copyright (c) 2013 NailBuster Software Inc.  all rights reserved.
/**********************

  This source code is provided 'as-is', without any express or implied warranty. 
  In no event will NailBuster Software Inc. be held liable for any damages arising from the use of this software.

      Permission is granted to use these components for non commercial applications, and to alter it for your needs,
    subject to the following restrictions:
    
  1. The origin of this software must not be misrepresented; you must not claim that you wrote the original source code 
     or components. If you use this software in a application, an acknowledgment in the product about/documentation would be appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
     You cannot distribute your modified sources of our component suite outside of your company.
  3. You cannot use this source or components in a tool or package designed to compete with NailBuster GUI component Suite. 
     For example,  you cannot modify and/or  improve these components and release under another component suite name.
  4. You cannot redistribute these source files outside of your compiled projects. All original Sources Files/Documentation 
     must originate from NailBuster Software Inc.  You cannot host or redistribute these source files. 
  
  If your application is used for commercial purposes, and will generate revenue directly or indirectly then you are required to 
  purchase a commercial license from NailBuster Software Inc.  Please visit www.nailbuster.com for purchasing information.
  If you have any questions about the license please contact us at david@nailbuster.com

**********************/


var disptx,px,py,sel,numitems,fx,cury,tw,sh,sw,surx,sury,visible_ytop,visible_ybot,sur_pos,ch,sprx,spry,sprxscale,spryscale,sprrot,curImageBlend,curAlpha,autoPos,numSprites,curSprite;

event_inherited();

numitems=array_length_1d(items);

draw_set_font(uiFont);
draw_set_halign(uiAlign);
draw_set_valign(fa_top);


if (uiZoomFactor==0.1) || (uiVisible==false) exit;  //for zooming   


tw=uiItemWidth;

//bottomline=((numitems*lineheight)-sprite_height) * -1;  //top drawy line for bottom clip.
curImageBlend=uiImageBlend;
curAlpha=uiAlpha;
     
   
if (!surface_exists(CurSurface)) {
    sury=ceil(sprite_height);
    surx=ceil(sprite_width+(uiItemWidth*2));  //max lineheight for one line item is 128 for now?
    fx=1; while (fx &lt; surx) { fx *= 2}; surx=fx;  //make sure power of 2
    fx=1; while (fx &lt; sury) { fx *= 2}; sury=fx;  //make sure power of 2  
    CurSurface = surface_create(surx,sury); 
};

surface_set_target(CurSurface);  
draw_clear_alpha(c_black, 0);
texture_set_interpolation(false);
sw=surface_get_width(CurSurface);   //get surface height

if uiDrawSquare { uiRadiusX=0;uiRadiusY=0;}

if uiDrawBackColor    //draw background
   {//draw the surface background 
    draw_roundrect_color_ext(0, 0, sw, sprite_height, uiRadiusX,uiRadiusY,uiBackColor,uiBackColor, false);   //fill
    draw_roundrect_color_ext(0, 0, sw, sprite_height, uiRadiusX,uiRadiusY,uiBorderBackColor,uiBorderBackColor,true);   //draw outline    
   } 
     
   
draw_set_halign(uiAlign);
numSprites=array_length_1d(sprites);

cury=0;  //always draw from 0;
visible_ytop=(drawy+uiLeftMargin)*-1;
visible_ybot=visible_ytop+sprite_width+1;  //clipping region for drawing bottom....
sur_pos=max(uiItemWidth-((drawy+uiLeftMargin)*-1),0); //surface y pos;

autoPos=visible_ytop;                 //auto selection pos
if uiAutoSelect {itemindex=-1;}

//zoomx=1;

for (fx=0;fx&lt;numitems;fx+=1)    //go through each item in the list;
{  
 if uiCustomDrawScript == -1
   {
     /////////////   STANDARD DRAWING   /////////////////////   
     if (cury)&lt;(visible_ytop-uiItemWidth)   //if not visible then draw at alpha 0 at postion 0....
              { cury+=tw
                sur_pos=cury-(visible_ytop-uiItemWidth);
//                zoomx +=1;  //for zoomindex feature.
              } 
     else if ((cury)&lt;=visible_ybot) //if we are below bottom  and above top...we draw to surface....                      
               {          
                if uiAutoSelect {if (cury &gt; autoPos) &amp;&amp; (itemindex==-1) itemindex=fx};
                disptx=items[fx];        
                while (string_width(disptx+'X') * uiXscale) &gt; (uiItemWidth)   //clip strings if they are too long
                      { 
                         disptx=string_delete(disptx,string_length(disptx),1);
                         if string_length(disptx)&lt;2 break;
                      }  
 

               draw_set_color(uiTextColor); 
                if (itemindex==fx) &amp;&amp; (uiDrawHilite==true)       //if hilited item
                     {
                        draw_rectangle_color(sur_pos,0, sur_pos+tw,sprite_height-1,uiHiliteBackColor,uiHiliteBackColor2,uiHiliteBackColor,uiHiliteBackColor2,false);   //fill hilite;
                        draw_set_color(uiHiliteColor);  //set text color  
                     }

                     
                //draw sprite if exists;
                if numSprites&gt;=fx
                   {if sprite_exists(sprites[fx])
                     {        sprxscale=uiSpriteScale;
                              spryscale=uiSpriteScale; 
//                              if uiZoomIndex!= -1 { if uiZoomIndex==(fx-zoomx) { sprxscale *=1.3; spryscale *= 1.3} }
                              if uiSpriteScale==0 { uiSpriteAlign=fa_left; uiSpriteAlignV=fa_top;}  //if auto-fit then no alignment.
                              px=0;py=0; 
                              if uiSpriteAlign==fa_left { sprx=5; } 
                                 else if uiSpriteAlign==fa_center {sprx= (uiItemWidth- (sprite_get_width(sprites[fx])*uiSpriteScale)) div 2; }
                                 else if uiSpriteAlign==fa_right {sprx =uiItemWidth - (sprite_get_width(sprites[fx])*uiSpriteScale); } 
                        
                              if uiSpriteAlignV==fa_top { spry=5; }
                                 else if uiSpriteAlignV==fa_middle { spry=( ((sprite_height - (sprite_get_height(sprites[fx]))*uiSpriteScale)) div 2);}  //center text vertically;
                                 else if uiSpriteAlignV==fa_bottom { spry=sprite_height - (sprite_get_height(sprites[fx])*uiSpriteScale); }
                                     
                              if uiSpriteScale==0 { 
                                                    sprxscale= uiItemWidth / (sprite_get_width(sprites[fx]));
                                                    spryscale= sprite_height / (sprite_get_height(sprites[fx]));
                                                    sprx=px+ (sprite_get_xoffset(sprites[fx])* sprxscale);
                                                    spry=py+ (sprite_get_yoffset(sprites[fx])* spryscale);  
                                                  }                              
                              //sprrot=uiSpriteAngle;
                              draw_sprite_ext(sprites[fx],uiSpriteIndex,sur_pos+sprx,spry,sprxscale,spryscale,0,curImageBlend,curAlpha);         
                                       
                    }   
                }       
                
                
                px=0;      
                if uiAlign==fa_left { px=5; } 
                   else if uiAlign==fa_center {px=( uiItemWidth) div 2; }
                   else if uiAlign==fa_right {px = uiItemWidth- 5; } 

                py=0;
                if uiAlignV==fa_top { py=5; } 
                 else if uiAlignV==fa_middle {py=(sprite_height div 2); }
                   else if uiAlignV==fa_bottom {py = sprite_height-string_height('Xypg'); } 

                   
              
                draw_text_transformed(sur_pos+2+px,py,disptx,uiXscale,uiYscale,0);     
    
    
                if (itemindex!=fx) &amp;&amp; uiDrawLines then  // draw lines between items
                        {
                             draw_set_color(uiBorderBackColor);
                             draw_line_width(sur_pos+tw,0,sur_pos+tw,sprite_height,1);    
                        }               
               cury+=tw;
               sur_pos+=tw;  //add to surface position;
             } //if visible
           else cury+=tw;  //else continue and draw nothing.                                 
           itemspos[fx]=cury;  //set the hilite array...
                
                
   }  else //////////////////   CUSTOM SCRIPT DRAW   /////////////////////////
      { 
        if uiAutoSelect {if (cury &gt; autoPos) &amp;&amp; (itemindex==-1) itemindex=fx};
        if itemindex==fx sel=true; else sel=false;
        curSprite=-1;
        if numSprites&gt;=fx {if sprite_exists(sprites[fx]) curSprite=sprites[fx];}

        if (cury)&lt;(visible_ytop-uiItemWidth)   //if not visible then draw at alpha 0 at postion 0....
              { draw_set_alpha(0);  //don't draw stuff that's not visible.  we still need to get the variable heights, so that is why we draw alpha=0 lines....
                cury+=script_execute(uiCustomDrawScript,self.id,fx,0,0,sprite_height,tw,items[fx],sel,curSprite);     
                draw_set_alpha(uiAlpha);  
                sur_pos=cury-(visible_ytop-uiItemWidth);
              } 
          else if ((cury)&lt;=visible_ybot) //if we are below bottom  and above top...we draw to surface....                      
               {
               ch=script_execute(uiCustomDrawScript,self.id,fx,sur_pos,0,sprite_height,tw,items[fx],sel,curSprite);
               cury+=ch;
               sur_pos+=ch;  //add to surface position;
               }
          else cury=cury+tw;  //do nothing....                      
        itemspos[fx]=cury;  //list for selection 
      }   
}  //for each item

if cury&gt;=sprite_width noscroll=false; else noscroll=true;  //weather we scroll or not

//set bottomline when possible variable length custom drawing...
//
if uiLeftMargin==0 {bottomline=(cury-(sprite_width)) * -1; } //top drawy line for bottom clip.
   else {bottomline=(cury-(sprite_width)+(uiItemWidth)) * -1;}  //top drawy line for bottom clip.
//draw bottom clip

texture_set_interpolation(true);
surface_reset_target();
draw_surface_part(CurSurface, uiItemWidth,0,sprite_width,sprite_height,x,y);  //128 is the per clip region


//draw header with uiTextLabel

if uiDrawHeader
{
//draw_set_color(uiBorderBackColor);  
//draw_rectangle(x, y-th, x+sprite_width, y, false);   //fill
}


if uiDrawBackColor    //draw Border
   {  
    draw_roundrect_color_ext(x, y, x+sprite_width, y+sprite_height, uiRadiusX,uiRadiusY,uiBorderBackColor,uiBorderBackColor, true);   //draw outline         
   } 


//draw uiTextLabel centered.
draw_set_color(uiBorderColor);
px= x + (sprite_width div 2);
draw_set_halign(fa_center);
if uiTextLabel !='' draw_text_transformed(px,y-string_height('Xypg')+2,uiTextLabel,uiXscale,uiYscale,0);  

//draw scrolling arrows

if (noscroll==false) &amp;&amp; (uiScrollArrows=true)  &amp;&amp; (uiEnabled)  
   { curArrowPulse += curArrowSpeed;
     if curArrowPulse &gt; 1 {curArrowSpeed *= -1;}
        else if curArrowPulse &lt; 0.3 {curArrowSpeed *= -1;}          
     if drawy&lt;0 draw_sprite_ext(sprite_index,3,x+30, y+sprite_height-20,1,1,180,uiScrollColor,curArrowPulse);
     if drawy&gt;bottomline draw_sprite_ext(sprite_index,3,x+sprite_width-30,y+sprite_height-52,1,1,0,uiScrollColor,curArrowPulse);              
   }


//if (surface_exists(CurSurface)) {surface_free(CurSurface);}




</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
